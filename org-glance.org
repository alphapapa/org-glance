#+TITLE: org-glance
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-glance
#+TAGS: License Documentation
#+TAGS: Feature Test Implementation Development
#+PROPERTY: header-args:emacs-lisp :noweb yes :tangle (cond ((seq-intersection '("Test") (org-get-tags-at)) "tests.el") ((seq-intersection '("Feature" "License") (org-get-tags-at)) "yes") (t "no"))
#+PROPERTY: header-args:markdown :tangle (cond ((seq-intersection '("Documentation") (org-get-tags-at)) "README.md") (t "no"))
#+PROPERTY: header-args:org :tangle no

* Hello
** README                                                                      :Documentation:
#+BEGIN_SRC markdown
Org-glance: walk in the woods with pleasure
===============================

Fast, clean and convenient way of traversing your org-mode forest.

Turn org-mode into context-aware bookmark storage, password manager,
flexible build system or whatever you can imagine with ease.
#+END_SRC
** License                                                                     :License:
#+BEGIN_SRC emacs-lisp
;;; org-glance.el --- org-mode traversing. Fast and convenient.

;; Copyright (C) 2018 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 29 September, 2018
;; Version: 0.1

;; Keywords: org-mode tools
;; Homepage: https://github.com/rails-to-cosmos/org-glance

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+END_SRC
* Requirements
** Implementation                                                              :Feature:
#+BEGIN_SRC emacs-lisp
(require 's)
(require 'cl-lib)
(require 'org)
#+END_SRC
** Testing                                                                     :Test:
#+BEGIN_SRC emacs-lisp
(require 'ert)
(require 'org-glance)
#+END_SRC
* Features
** temp-org-buffer                                                             :Test:
#+NAME: with-temp-org-buffer
#+BEGIN_SRC emacs-lisp
(defmacro with-temp-org-buffer (s &rest forms)
  "Create a temporary org-mode buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (org-mode)
       (goto-char 0)
       (insert ,s)
       (goto-char 0)
       ,@forms)))
#+END_SRC
** org-glance                                                                  :Feature:
*** Documentation                                                             :Documentation:
#+NAME: org-glance-doc
#+BEGIN_SRC org
Use optional ARGS to customize your glancing blows:
- SCOPE :: org-file or SCOPE from org-map-entries (org.el)
- PROMPT :: completing read title (default: "Glance: ")
- SEPARATOR :: completing read entry separator (default: " → ")
- FILTER :: lambda to filter entries in completing read or
  - 'links :: keep entries with link in title
  - 'encrypted :: keep entries with :crypt: tag
- ACTION :: lambda to call on selected entry
  - if entry has an org-link in title, browse it
  - if entry has HANDLER property, read-eval it
- HANDLER :: property name to read-eval on select (default: "HANDLER")

\(fn [:scope SCOPE] [:prompt PROMPT] [:separator SEPARATOR] [:filter FILTER] [:action ACTION] [:handler HANDLER])
#+END_SRC
*** Implementation                                                            :Implementation:
#+BEGIN_SRC emacs-lisp
(defun org-glance (&rest args)
<<org-glance-doc()>>
  (let* ((scope     (or (plist-get args :scope)          nil))
         (scope*    (cond ((stringp scope) (list scope)) (t scope)))

         (filter    (or (plist-get args :filter)         (lambda nil t)))
         (filter*   (cond ((eq filter 'links) (lambda () (org-match-line (format "^.*%s.*$" org-bracket-link-regexp))))
                          ((eq filter 'encrypted) (lambda () (seq-intersection (list "crypt") (org-get-tags-at))))
                          (t filter)))

         (handler   (or (plist-get args :handler)        "HANDLER"))
         (prompt    (or (plist-get args :prompt)         "Glance: "))
         (separator (or (plist-get args :separator)      " → "))
         (action    (or (plist-get args :action)         (lambda nil (org-glance/handle-entry handler)))))

    (cl-flet ((traverse ()
                        (let* ((mark (point-marker))
                               (title (s-join separator (org-get-outline-path t))))
                          (when (funcall filter*)
                            (cons title mark)))))

      (org-glance/compl-map prompt (org-map-entries #'traverse nil scope*) action))))
#+END_SRC
** handle-entry                                                                :Feature:
*** Documentation                                                             :Documentation:
#+NAME: handle-entry-doc
#+BEGIN_SRC org
Try to handle current org-entry:
1. If there is an org-link, browse it.
2. If not, call HANDLER.
#+END_SRC
*** Implementation                                                            :Implementation:
#+BEGIN_SRC emacs-lisp
(defun org-glance/handle-entry (handler)
<<handle-entry-doc()>>
  (cond ((org-match-line (format "^.*%s.*$" org-bracket-link-regexp)) (org-glance/follow-org-link-at-point))
        ((org-entry-get nil handler) (let ((action (read (org-entry-get nil handler))))
                                       (cond ((symbolp action) (read (macroexpand (list 'org-sbe (symbol-name action)))))
                                             (t (eval action)))))))
#+END_SRC
*** Tests
**** can-handle-org-links                                                    :Test:
***** Predicate
#+BEGIN_SRC emacs-lisp
(defun org-glance-predicate/can-handle-org-links ()
  "Can we handle org-links?"
  (with-temp-org-buffer "* [[elisp:(+%201%202)][elisp]]"
                        (let ((unread-command-events (listify-key-sequence (kbd "elisp RET")))
                              (begin-marker (with-current-buffer (messages-buffer)
                                              (point-max-marker))))
                          (org-glance)
                          (string= (string-trim (with-current-buffer (messages-buffer)
                                                  (buffer-substring begin-marker (point-max))))
                                   "(+ 1 2) => 3"))))
#+END_SRC
***** Explanation
#+BEGIN_SRC emacs-lisp
(defun org-glance-test-explainer/can-handle-org-links ()
  (message "Handling org-links feature doesn't work properly"))

(put 'org-glance-predicate/can-handle-org-links
     'ert-explainer
     'org-glance-test-explainer/can-handle-org-links)
#+END_SRC
***** Test
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-org-links ()
  "Test that we can handle org-links."
  (should (org-glance-predicate/can-handle-org-links)))
#+END_SRC
**** can-handle-default-property                                             :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-default-property ()
  "Test that we can use default handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:HANDLER: (+ 1 9)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance) 10)))))
#+END_SRC
**** can-handle-custom-property                                              :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-custom-property ()
  "Test that we can use custom handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:CUSTOM_HANDLER: (+ 1 11)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance :handler "CUSTOM_HANDLER") 12)))))
#+END_SRC
**** can-handle-symbolic-property                                            :Test:
***** Predicate
#+BEGIN_SRC emacs-lisp
(defun org-glance-predicate/can-handle-symbolic-property ()
  "Can we handle symbolic property as org-babel block name?"
  (with-temp-org-buffer
   "
,* Please, handle custom block
:PROPERTIES:
:CUSTOM_HANDLER: custom-block
:END:

,#+NAME: custom-block
,#+BEGIN_SRC emacs-lisp
(+ 15 16)
,#+END_SRC
"
   (let ((unread-command-events (listify-key-sequence (kbd "Plea RET"))))
     (= (org-glance :handler "CUSTOM_HANDLER") 31))))
#+END_SRC
***** Explanation
#+BEGIN_SRC emacs-lisp
(defun org-glance-test-explainer/can-handle-symbolic-property ()
  (message "Failed to handle symbolic property as org-babel block name"))

(put 'org-glance-predicate/can-handle-symbolic-property
     'ert-explainer
     'org-glance-test-explainer/can-handle-symbolic-property)
#+END_SRC
***** Test
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-symbolic-property ()
  "Test that we can handle symbolic properties."
  (should (org-glance-predicate/can-handle-symbolic-property)))
#+END_SRC
** compl-map                                                                   :Feature:
*** Documentation                                                             :Documentation:
#+NAME: compl-map-doc
#+BEGIN_SRC org
PROMPT org-completing-read on ENTRIES and call ACTION on selected.
If there is only one entry, call ACTION without completing read.
If there is no entries, raise exception.
#+END_SRC
*** Implementation                                                            :Implementation:
#+BEGIN_SRC emacs-lisp
(defun org-glance/compl-map (prompt entries action)
<<compl-map-doc()>>
  (let* ((entries* (remove 'nil entries))
         (choice (cond ((= (length entries*) 1) (caar entries*))
                       ((= (length entries*) 0) (error "Empty set."))
                       (t (org-completing-read prompt entries*))))
         (marker (cdr (assoc-string choice entries*))))
    (org-goto-marker-or-bmk marker)
    (funcall action)))
#+END_SRC
** follow-org-link-at-point                                                    :Feature:
*** Documentation                                                             :Documentation:
#+NAME: follow-org-link-at-point-doc
#+BEGIN_SRC org
Browse org-link at point.
#+END_SRC
*** Implementation                                                            :Implementation:
#+BEGIN_SRC emacs-lisp
(defun org-glance/follow-org-link-at-point ()
<<follow-org-link-at-point-doc()>>
  (let ((link (buffer-substring-no-properties
               (save-excursion (org-beginning-of-line) (point))
               (save-excursion (org-end-of-line) (point))))
        (org-link-frame-setup (acons 'file 'find-file org-link-frame-setup)))
    (org-open-link-from-string link)))
#+END_SRC
** filtering                                                                   :Feature:
*** Documentation                                                             :Documentation:
*** Implementation                                                            :Implementation:
*** Tests
**** filter-removes-entries                                                  :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-removes-entries ()
  "Test filtering."
  (with-temp-org-buffer
"
,* First
,* Second
,* Third
,* Security
"
(let ((unread-command-events (listify-key-sequence (kbd "third RET"))))
  (should-error (org-glance :filter (lambda () (org-match-line "^.*Sec")))))))
#+END_SRC
**** filter-doesnt-remove-suitable-entries                                   :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-doesnt-remove-suitable-entries ()
  "Test filtering."
  (with-temp-org-buffer
"
,* First
,* Second
,* Third
"
(let ((unread-command-events (listify-key-sequence (kbd "sec RET"))))
  (should (eq nil (org-glance :filter (lambda () (org-match-line "^.*Second"))))))))
#+END_SRC
** provide                                                                     :Feature:
*** Implementation
#+BEGIN_SRC emacs-lisp
(provide 'org-glance)
;;; org-glance.el ends here
#+END_SRC
*** Tests
**** feature-provision                                                       :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/feature-provision ()
  (should (featurep 'org-glance)))
#+END_SRC
** org-block-execute                                                           :Development:
#+NAME: org-block-execute
#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:org (body params)
  "Execute an org-block code with org-babel.
Print BODY as multiline string escaping quotes.
No PARAMS needed yet.  This function is called
by `org-babel-execute-src-block'."
  (let ((escaped-body
         (with-temp-org-buffer body
           (while (search-forward "\"" nil t)
             (replace-match "\\\"" "FIXEDCASE" "LITERAL"))
           ;; (org-table-recalculate-buffer-tables)
           (buffer-substring-no-properties (point-min) (point-max)))))
    (concat "\"" escaped-body "\"")))
#+END_SRC
* Devtools
** Build                                                                       :build:
:PROPERTIES:
:HANDLER:  (and (org-sbe "report") (org-glance-devtools/build-report))
:END:

#+NAME: init-environment
#+BEGIN_SRC emacs-lisp
(defun org-glance-devtools/build ()
  (interactive)
  (save-mark-and-excursion
    (org-save-outline-visibility t
      (org-glance
       :filter (lambda () (seq-intersection '("build") (org-get-tags-at)))))))

(local-set-key (kbd "C-x y m") 'org-glance-devtools/build)
#+END_SRC

#+NAME: report
#+BEGIN_SRC emacs-lisp
(defun org-glance-devtools/build-report ()
  (let ((report (read (org-sbe "build"))))
    (caddr report)
    (when (> (caddr report) 0)
      (pop-to-buffer "*org-glance-tests*"))
    (apply 'message (append '("Build finished. Ran %d tests, %d were as expected, %d failed, %d skipped") report))))
#+END_SRC

#+NAME: build
#+BEGIN_SRC emacs-lisp :tangle no :results silent
(let ((test-file "tests.el")
      (impl-file "org-glance.el"))
  (delete-file test-file)
  (delete-file impl-file)
  (org-sbe "org-block-execute")
  (org-sbe "with-temp-org-buffer")
  (org-babel-tangle)
  (load-file impl-file)
  (byte-compile-file impl-file)
  (load-file test-file)

  (let* ((test-$ "^org-glance-test/")
         (test-buffer "*org-glance-tests*")
         (ert-stats (ert-run-tests-interactively test-$ test-buffer))
         (expected (ert-stats-completed-expected ert-stats))
         (unexpected (ert-stats-completed-unexpected ert-stats))
         (skipped (ert-stats-skipped ert-stats))
         (total (ert-stats-total ert-stats)))
    (list total expected unexpected skipped)))
#+END_SRC
* Applications
** org-glance-build
** org-glance-passwords
** org-glance-bookmarks
** org-glance-fs
* Local Variables
# Local Variables:
# eval: (and (org-sbe "report") (org-glance-devtools/build-report) (org-sbe "init-environment"))
# org-use-tag-inheritance: t
# org-src-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
