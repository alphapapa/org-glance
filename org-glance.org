#+TITLE: org-glance
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-glance
#+TAGS: License Documentation
#+TAGS: Feature Test
#+PROPERTY: header-args:emacs-lisp :noweb yes :tangle (cond ((seq-intersection '("Test") (org-get-tags-at)) "org-glance-tests.el") ((seq-intersection '("Defaults" "Feature" "License") (org-get-tags-at)) "yes") (t "no")) :results silent
#+PROPERTY: header-args:markdown :tangle (cond ((seq-intersection '("Documentation") (org-get-tags-at)) "README.md") (t "no"))
#+PROPERTY: header-args:org :tangle no

#+TBLNAME: Components
| ! | Component | Available |
|---+-----------+-----------|
| # | [[elisp:(org-sbe%20"devtools-build-require")][Devtools]]  | YES       |
#+TBLFM: $3='(if (fboundp 'org-glance-devtools/build) "YES" "NO")

* Hello
** README                                                                      :Documentation:
#+BEGIN_SRC markdown
Org-glance: walk in the woods with pleasure
===============================

Fast, clean and convenient way of traversing your org-mode forest.

Turn org-mode into context-aware bookmark storage, password manager,
flexible build system or whatever you can imagine with ease.

## Running tests

### Batch mode

    emacs -batch -l ert -l org-glance-tests.el -f ert-run-tests-batch-and-exit

### Org-mode

Browse link `Setup development environment`. After that you can build
project using `C-x y m` key or running `org-glance-devtools/build`
command from `org-glance.org` buffer.
#+END_SRC
** License                                                                     :License:
#+BEGIN_SRC emacs-lisp
;;; org-glance.el --- org-mode traversing. Fast and convenient.

;; Copyright (C) 2018 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 29 September, 2018
;; Version: 0.1

;; Keywords: org-mode tools
;; Homepage: https://github.com/rails-to-cosmos/org-glance

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+END_SRC
* Requirements
** Implementation                                                              :Feature:
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'cl-lib)
(require 'subr-x)
(require 'seq)

(defvar org-glance--scope-buffer-name "*org-glance-scope*")
(setq org-glance--cache (make-hash-table :test 'equal))

(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
   (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+END_SRC
** Testing                                                                     :Test:
#+BEGIN_SRC emacs-lisp
(require 'ert)
(load-file "org-glance.el") ;; for batch-mode
(require 'org-glance)
#+END_SRC

#+NAME: trim-string
#+BEGIN_SRC emacs-lisp
(defun trim-string (string)
  "Remove white spaces in beginning and ending of STRING.
White space here is any of: space, tab, emacs newline (line feed, ASCII 10)."
  (replace-regexp-in-string "\\`[ \t\n]*" "" (replace-regexp-in-string "[ \t\n]*\\'" "" string)))
#+END_SRC

#+NAME: with-temp-org-buffer
#+BEGIN_SRC emacs-lisp
(defmacro with-temp-org-buffer (s &rest forms)
  "Create a temporary org-mode buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (org-mode)
       (goto-char 0)
       (insert ,s)
       (goto-char 0)
       ,@forms)))

(defmacro org-glance--with-buffer-contents (s &rest forms)
  "Create a temporary buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (progn
         (goto-char 0)
         (insert ,s)
         (goto-char 0)
         ,@forms))))

(defmacro org-glance--with-temp-filebuffer (&rest body)
  "Open temp-file with org-glance prefix into a temporary buffer
execute BODY there like `progn', then kill the buffer and delete
the file returning the result of evaluating BODY."
  `(save-window-excursion
     (let ((fn (make-temp-file "org-glance-")))
       (find-file fn)
       (unwind-protect
           ,@body
         (save-buffer)
         (kill-buffer)
         (delete-file fn)))))
#+END_SRC
* Defaults                                                                      :Defaults:
#+BEGIN_SRC emacs-lisp
(defvar org-glance-defaults--separator " → ")
#+END_SRC
* Features [4/11]
** TODO org-glance [1/2]                                                       :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance (&rest args)
  "Use optional ARGS to customize your glancing blows:
- SCOPE :: org-file or SCOPE from org-map-entries (org.el)
- PROMPT :: completing read title (default: \"Glance: \")
- SEPARATOR :: completing read entry separator (default: \" → \")
- FILTER :: list or one filter of type lambda/symbol/string to specify entries in completing read.

  Possible default filters:
  - links :: keep entries with link in title
  - encrypted :: keep entries with :crypt: tag

  You can customize default filters by setting org-glance/default-filters variable.

- ACTION :: lambda to call on selected entry
  - if entry has an org-link in title, browse it
  - if entry has HANDLER property, read-eval it
- HANDLER :: property name to read-eval on select (default: \"HANDLER\")
- OUTLINE-IGNORE :: list of strings to ignore in outline-path

- INPLACE :: do not build scope file if specified

\(fn [:scope SCOPE] [:prompt PROMPT] [:separator SEPARATOR] [:filter FILTER] [:action ACTION] [:handler HANDLER])"
  (let* ((user-scopes (or (plist-get args :scope)          nil))
         (aggregated-scopes (org-glance--aggregate-scopes user-scopes))

         (user-filter (or (plist-get args :filter)       (lambda () t)))
         (filters (org-glance--filter-predicates user-filter))

         (outline-ignore (or (plist-get args :outline-ignore) nil))

         ;; user predicates
         (save-outline-visibility-p (or (plist-get args :save-outline-visibility-p) nil))
         (inplace-p                 (or (plist-get args :inplace) nil))

         (handler   (or (plist-get args :handler)        "HANDLER"))
         (prompt    (or (plist-get args :prompt)         "Glance: "))
         (separator (or (plist-get args :separator)      " → "))
         (action    (or (plist-get args :action)         (lambda nil (org-glance--handle-entry handler))))

         (entries (org-glance--entries
                   :scope aggregated-scopes
                   :separator separator
                   :outline-ignore outline-ignore
                   :filters filters
                   :inplace inplace-p))
         (-> (assert entries nil (format "Nothing to glance for in scopes %s" (prin1-to-string aggregated-scopes)))))

    (org-glance/compl-map prompt entries action save-outline-visibility-p)
    ;; (unwind-protect
    ;;     (org-glance/compl-map prompt entries action save-outline-visibility-p)
    ;;   (with-current-buffer (get-buffer-create org-glance--scope-buffer-name)
    ;;     (erase-buffer)
    ;;     (kill-buffer)))
    ))
#+END_SRC
*** TODO Tests
** TODO outliner                                                               :Feature:
#+BEGIN_SRC emacs-lisp
(defun org-glance--get-outline-path-and-marker-at-point (&rest args)
  "Return outline path of current `'org-mode`' entry.

Org node titles separated by SEPARATOR, titles specified in
OUTLINE-IGNORE will be ignored.

All FILTERS lambdas must be t."
  (let* ((separator           (or (plist-get args :separator)           org-glance-defaults--separator))
         (outline-ignore (or (plist-get args :outline-ignore) nil))
         (filters             (or (plist-get args :filters)             nil))

         (mark (point-marker))
         (item (org-entry-get (point-marker) "ITEM"))

         (outline (cl-set-difference
                   (append (butlast (org-get-outline-path t)) (list item))
                   outline-ignore :test 'string=))

         (title (mapconcat 'identity outline separator)))
    (when (and (cl-every (lambda (fp) (if fp (funcall fp) nil)) filters)
               (not (string-empty-p (s-trim title))))
      (list title mark))))
#+END_SRC
** TODO cache                                                                  :Feature:
#+BEGIN_SRC emacs-lisp
(defun org-glance-cache--add-scope (scope-name entries)
  (loop for (title level) in entries
        for i below (length entries)
        with prev-level
        initially (progn
                    (org-insert-heading nil nil t)
                    (insert scope-name)
                    (org-insert-subheading nil))
        do (progn
             (insert title)
             (when prev-level
               (cond ((> prev-level level) (dotimes (ld (- prev-level level)) (org-do-promote)))
                     ((< prev-level level) (dotimes (ld (- level prev-level)) (org-do-demote))))))
        when (< (+ i 1) (length entries))
        do (progn
             (org-insert-heading-respect-content)
             (setq prev-level level))))

(defun org-glance-cache--get-scope (scope-name)
  (org-element-map (org-element-parse-buffer 'headline) 'headline
    (lambda (headline)
      (let ((level (org-element-property :level headline))
            (title (org-element-property :title headline))
            (begin (org-element-property :begin headline))
            (end (org-element-property :end headline)))
        (when (and (= level 1) (string= title scope-name))
          (list begin end))))))

(defun org-glance-cache--insert-contents (fob scope-type)
  (case scope-type
    ('file (insert-file-contents fob))
    ('file-buffer (insert-file-contents (buffer-file-name fob)))
    ('buffer (insert-buffer-substring-no-properties fob))))

(defun org-glance-cache--read-contents (fob scope-type)
  (case scope-type
      ('file (find-file file-or-buffer))
      ('file-buffer (switch-to-buffer file-or-buffer))
      ('buffer (switch-to-buffer file-or-buffer))))
#+END_SRC
** TODO get-entries [1/2]                                                      :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance--entries (&rest args)
  "Return glance entries by SCOPE.

Specify SEPARATOR and OUTLINE-IGNORE to customize
outline-paths appearence.

When INPLACE flag specified, do not modify *org-glance-scope* buffer.

Add some FILTERS to filter unwanted entries."
  (let* ((scope               (or (plist-get args :scope)               nil))
         (-> (assert scope nil "You must specify :scope argument."))
         (-> (assert (listp scope) nil "Scope must be instance of list."))

         (separator           (or (plist-get args :separator)           org-glance-defaults--separator))
         (outline-ignore      (or (plist-get args :outline-ignore)      nil))
         (inplace-p           (or (plist-get args :inplace)             nil))
         (filters             (or (plist-get args :filters)             nil))

         ;; Possible beautify and optimization: switch to opened buffer instead of finding file
         ;; (live-buffers (remove nil (mapcar 'buffer-file-name (buffer-list))))

         (scope-type-getter (lambda (file-or-buffer)
                              (cond ((and (stringp file-or-buffer) (file-exists-p file-or-buffer)) 'file)
                                    ((and (bufferp file-or-buffer) (buffer-file-name file-or-buffer) (file-exists-p (buffer-file-name file-or-buffer))) 'file-buffer)
                                    ((bufferp file-or-buffer) 'buffer))))

         (scope-name-getter (lambda (file-or-buffer scope-type)
                              (case scope-type
                                ('file (expand-file-name file-or-buffer))
                                ('file-buffer (expand-file-name (buffer-file-name file-or-buffer)))
                                ('buffer (buffer-name file-or-buffer)))))

         (outliner (apply-partially
                    'org-glance--get-outline-path-and-marker-at-point
                    :separator separator
                    :outline-ignore outline-ignore
                    :filters filters))

         (implant (lambda (file-or-buffer scope-type)
                    (with-current-buffer (get-buffer-create org-glance--scope-buffer-name)
                      (org-mode)

                      (let* ((entries (with-temp-buffer
                                        (org-mode)
                                        (org-glance-cache--insert-contents file-or-buffer scope-type)
                                        (org-map-entries (lambda () (let* ((element (org-element-at-point))
                                                                      (title (org-element-property :title element))
                                                                      (level (org-element-property :level element)))
                                                                      (list title level))))))
                             (scope-name (funcall scope-name-getter file-or-buffer scope-type))
                             (cached-scope (org-glance-cache--get-scope scope-name)))

                        (when (and (not cached-scope) (> (length entries) 0))
                          (org-glance-cache--add-scope scope-name entries)
                          (setq cached-scope (org-glance-cache--get-scope scope-name)))

                        (when-let ((scope-point (caar cached-scope)))
                          (save-excursion
                            (goto-char scope-point)
                            (org-map-entries outliner nil 'tree)))))))

         (visitor (lambda (file-or-buffer scope-type)
                    (save-window-excursion
                      (org-glance-cache--read-contents file-or-buffer scope-type)
                      (org-map-entries outliner))))

         (handler (if inplace-p visitor implant)))

    (loop for file-or-buffer in scope
          append (let* ((scope-type (funcall scope-type-getter file-or-buffer))
                        (entries (funcall handler file-or-buffer scope-type)))
                   (remove nil entries)))))
#+END_SRC
*** TODO Tests
** TODO sort-entries
*** Implementation
*** Tests
**** classification problem
classes:
- i.e. bookmarks or passwords
- items must be normally distributed
- hashtable of items?

independent variables (normalization needed):
- (sxhash (buffer-hash))
- (point)
- (sxhash (substring-no-properties (thing-at-point 'line)))
- (sxhash (buffer-file-name))
- (sxhash (save-window-excursion (org-clock-goto) (substring-no-properties (thing-at-point 'line))))
- org-clock tags, properties
- buffer major mode

connections:
-

#+BEGIN_SRC emacs-lisp
;; (require 'eieio)

;; (defclass og-context (eieio-persistent)
;;   ((mode
;;     :type symbol
;;     :initarg :mode
;;     :initform (buffer-mode))

;;    (file
;;     :type string
;;     :initarg :file
;;     :initform "~/.context")

;;    (target
;;     :type string
;;     :initarg :target)

;;    (targets
;;     :type cl-hash-table
;;     :initform (make-hash-table :test 'equal)
;;     :allocation :class
;;     :documentation "Targets with features."))
;;   "Org-glance context.")

;; (cl-defmethod initialize-instance :after ((obj og-context) &rest _)
;;   (with-slots (mode target targets) obj
;;     (let* ((features (gethash target targets (make-hash-table :test 'equal)))
;;            (coeff (+ (gethash mode features 0) 1)))
;;       (puthash mode coeff features)
;;       (puthash target features targets))))

;; (require 'json)

;; ;; slots
;; (loop for slot in (eieio-class-slots og-context)
;;       collect (eieio-slot-descriptor-name slot))

;; ;; targets
;; (with-temp-file "~/.context"
;;   (insert (json-encode-hash-table (oref-default og-context targets))))

;; (json-read-file "~/.context")
#+END_SRC
** DONE handle-entry [2/2]                                                     :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance--handle-entry (handler)
  "Try to handle current org-entry:
1. If there is an org-link, browse it.
2. If not, read-eval HANDLER property."
  (cond ((org-match-line (format "^.*%s.*$" org-bracket-link-regexp)) (org-glance/follow-org-link-at-point))
        ((org-entry-get nil handler) (let ((action (read (org-entry-get nil handler))))
                                       (cond ((symbolp action) (read (macroexpand (list 'org-sbe (symbol-name action)))))
                                             (t (eval action)))))))
#+END_SRC
*** DONE Tests [4/4]
**** DONE Can handle org-links                                               :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/can-handle-org-links-p ()
  "Can we handle org-links?"
  (with-temp-org-buffer
   "* [[elisp:(+%201%202)][elisp]]"
   (let ((org-confirm-elisp-link-function nil)
         (unread-command-events (listify-key-sequence (kbd "elisp RET")))
         (begin-marker (with-current-buffer (messages-buffer)
                         (point-max-marker))))
     (org-glance)
     (string= (trim-string
               (with-current-buffer (messages-buffer)
                 (buffer-substring begin-marker (point-max))))
              "(+ 1 2) => 3"))))

(defun org-glance-test-explainer/can-handle-org-links ()
  "Handling org-links feature doesn't work properly")

(put 'org-glance-req/can-handle-org-links-p
     'ert-explainer
     'org-glance-test-explainer/can-handle-org-links)

(ert-deftest org-glance-test/can-handle-org-links ()
  "Test that we can handle org-links."
  (should (org-glance-req/can-handle-org-links-p)))
#+END_SRC

#+RESULTS:
: org-glance-test/can-handle-org-links

**** DONE Can handle default lisp properties                                 :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-default-property ()
  "Test that we can use default handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:HANDLER: (+ 1 9)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance) 10)))))
#+END_SRC
**** DONE Can handle custom lisp properties                                  :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-custom-property ()
  "Test that we can use custom handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:CUSTOM_HANDLER: (+ 1 11)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance :handler "CUSTOM_HANDLER") 12)))))
#+END_SRC
**** DONE Can handle custom babel properties                                 :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/can-handle-symbolic-property ()
  "Can we handle symbolic property as org-babel block name?"
  (with-temp-org-buffer
   "
,* Please, handle custom block
:PROPERTIES:
:CUSTOM_HANDLER: custom-block
:END:

,#+NAME: custom-block
,#+BEGIN_SRC emacs-lisp
(+ 15 16)
,#+END_SRC
"
   (let ((org-confirm-babel-evaluate nil)
         (unread-command-events (listify-key-sequence (kbd "Plea RET"))))
     (= (org-glance :handler "CUSTOM_HANDLER") 31))))

(defun org-glance-test-explainer/can-handle-symbolic-property ()
  "Failed to handle symbolic property as org-babel block name")

(put 'org-glance-req/can-handle-symbolic-property
     'ert-explainer
     'org-glance-test-explainer/can-handle-symbolic-property)

(ert-deftest org-glance-test/can-handle-symbolic-property ()
  "Test that we can handle symbolic properties."
  (should (org-glance-req/can-handle-symbolic-property)))
#+END_SRC
** DONE compl-map [2/2]                                                        :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance/compl-map (prompt entries action &optional save-outline-visibility-p)
  "PROMPT org-completing-read on ENTRIES and call ACTION on selected.
If there is only one entry, call ACTION without completing read.
If there are no entries, raise exception."
  (let* ((entries-count (length entries))
         (choice (cond ((= entries-count 1) (caar entries))
                       ((= entries-count 0) (error "Empty set."))
                       (t (org-completing-read prompt entries))))
         (marker (cadr (assoc-string choice entries)))
         (source-buffer (current-buffer)))

    ;; og-context debug
    ;; (let ((context (og-context :target choice)))
    ;;   (eieio-persistent-save context))
    ;; debug end

    (if save-outline-visibility-p
        (org-save-outline-visibility t
          (org-goto-marker-or-bmk marker)

          (ledna/set-property "CONTEXT" "hello")

          (funcall action))
      (progn
        (org-goto-marker-or-bmk marker)
        (funcall action)))))
#+END_SRC

#+RESULTS:
: org-glance/compl-map

*** DONE Tests
**** DONE Can complete non-file-visiting buffers                             :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/compl-non-file-buffer-p ()
  "Return t if org-glance can work properly from non-file buffers."
  (let ((expr "(+ 13 17)"))
    (org-glance--with-buffer-contents
     (format "
,* Hello World
:PROPERTIES:
:HANDLER: %s
:END:" expr)
     (let ((buf (current-buffer)))
       (with-temp-buffer
         (= (org-glance :scope (list buf))
            (eval (read expr))))))))

(ert-deftest org-glance-test/compl-non-file-buffer ()
  (should (org-glance-req/compl-non-file-buffer-p)))
#+END_SRC
** TODO follow-org-link-at-point [1/2]                                         :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance/follow-org-link-at-point ()
  "Browse org-link at point."
  (let ((link (buffer-substring-no-properties
               (save-excursion (org-beginning-of-line) (point))
               (save-excursion (org-end-of-line) (point))))
        (org-link-frame-setup (cl-acons 'file 'find-file org-link-frame-setup)))
    (org-open-link-from-string link)))
#+END_SRC
*** TODO Tests
** TODO scoping [1/2]                                                          :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance--aggregate-scopes (&optional scopes)
  "Provides list of scopes (scope may be buffer or existing file).
Without specifying SCOPES it returns list with current buffer."

  (let* ((scopes (cond ((or (stringp scopes)
                            (and (symbolp scopes)
                                 (not (null scopes))))
                        (list scopes))
                       (t scopes)))

         (ascopes (cl-loop for scope in scopes

                           ;; collect buffers
                           when (bufferp scope)
                           collect scope

                           ;; collect functions that return buffers or filenames
                           when (functionp scope)
                           collect (when-let ((fob (funcall scope)))
                                     (if (bufferp fob)
                                         fob
                                       (or (get-file-buffer (expand-file-name fob))
                                           (expand-file-name fob))))

                           ;; collect file names
                           when (and (stringp scope) (file-exists-p (expand-file-name scope)))
                           collect (or (get-file-buffer (expand-file-name scope))
                                       (expand-file-name scope)))))

    (or (remove 'nil (seq-uniq ascopes))
        (list (current-buffer)))))
#+END_SRC
*** TODO Tests [2/4]
**** DONE Return must contain no duplicates                                  :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/scopes-contain-no-duplicates-p ()
  "Return t if glance can deal with duplicates."
  (let ((scopes
         (org-glance--with-temp-filebuffer
          (org-glance--aggregate-scopes
           (list
            ;; buffer
            (current-buffer)

            ;; filename
            (buffer-file-name)

            ;; function that returns buffer
            'current-buffer

            ;; function that returns filename
            'buffer-file-name)))))
    (= (length scopes) 1)))

(ert-deftest org-glance-test/scopes-contain-no-duplicates ()
  (should (org-glance-req/scopes-contain-no-duplicates-p)))
#+END_SRC
**** DONE Proper handling lambda with nil return                             :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/scopes-can-handle-nil-lambdas-p ()
  "Don't nil lambdas break glance?"
  (not (null
        (condition-case nil
            (org-glance--aggregate-scopes (list (lambda () nil)))
          (error nil)))))

(ert-deftest org-glance-test/scopes-can-handle-nil-lambdas ()
  (should (org-glance-req/scopes-can-handle-nil-lambdas-p)))
#+END_SRC
**** TODO Input must handle scopes of types: buffer, fun, filename
**** TODO Proper handle nil input
** DONE filtering [2/2]                                                        :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defvar org-glance/default-filters '((links . (lambda () (org-match-line (format "^.*%s.*$" org-bracket-link-regexp))))
                                     (encrypted . (lambda () (seq-intersection (list "crypt") (org-get-tags-at))))))

(defun org-glance--filter-predicates (filter)
  "Factorize FILTER into list of predicates. Acceptable FILTER values:
- list of symbols (possible default filters) and lambdas (custom filters)
- string name of default filter
- symbolic name of default filter
- lambda function with no params called on entry"
  (cond ((functionp filter) (list filter))
        ((symbolp filter) (list (alist-get filter org-glance/default-filters)))
        ((stringp filter) (list (alist-get (intern filter) org-glance/default-filters)))
        ((listp filter) (cl-loop for elt in filter
                                 when (functionp elt) collect elt
                                 when (symbolp elt)   collect (alist-get elt org-glance/default-filters)
                                 when (stringp elt)   collect (alist-get (intern elt) org-glance/default-filters)))
        (t (error "Unable to recognize filter."))))
#+END_SRC
*** DONE Tests
**** DONE Filter produces proper predicates                                  :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/filter-produces-proper-predicates-p (input expected)
  "Can we split user filter into atomic predicates?"
  (equal (org-glance--filter-predicates input) expected))

(defun org-glance-test-explainer/filter-produces-proper-predicates (filter expected)
  (cond ((functionp filter) "Unable to resolve lambda filter")
        ((symbolp filter) "Unable to resolve symbolic filter")
        ((stringp filter) "Unable to resolve string filter")
        ((listp filter) (cl-loop for elt in filter
                                 when (functionp elt) return "Unable to resolve lambda from filter list"
                                 when (symbolp elt)   return "Unable to resolve symbol from filter list"
                                 when (stringp elt)   return "Unable to resolve string from filter list"))
        (t "Unrecognized filter must raise an error")))

(put 'org-glance-req/filter-produces-proper-predicates-p
     'ert-explainer
     'org-glance-test-explainer/filter-produces-proper-predicates)

(ert-deftest org-glance-test/filter-produces-proper-predicates-lambda ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (lambda () t) '((lambda () t)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-symbol ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           'links (list (alist-get 'links org-glance/default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-string ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           "links" (list (alist-get 'links org-glance/default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-list ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (list 'links (lambda () t) "links")
           (list (alist-get 'links org-glance/default-filters)
                 (lambda () t)
                 (alist-get 'links org-glance/default-filters)))))
#+END_SRC
**** DONE Filter removes entries                                             :Test:
#+BEGIN_SRC emacs-lisp
(defun org-glance-req/filter-removes-entries-p (filter content input)
  (with-temp-org-buffer content
   (let ((unread-command-events (listify-key-sequence (kbd (format "%s RET" input)))))
     (condition-case nil
         (org-glance :filter filter)
       (error t)))))

(ert-deftest org-glance-test/filter-removes-entries ()
  "Test filtering."
  (should
   (org-glance-req/filter-removes-entries-p
    (lambda () (org-match-line "^.*Sec"))

    "* First
     ,* Second
     ,* Third
     ,* Security"

    "Third")))
#+END_SRC
**** DONE Filter doesn't remove suitable entries                             :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-doesnt-remove-suitable-entries ()
  "Test filtering."
  (with-temp-org-buffer "
,* First
,* Second
,* Third
"
                        (let ((unread-command-events (listify-key-sequence (kbd "sec RET"))))
                          (should (eq nil (org-glance :filter (lambda () (org-match-line "^.*Second"))))))))
#+END_SRC
** DONE provide [2/2]                                                          :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(provide 'org-glance)
;;; org-glance.el ends here
#+END_SRC
*** DONE Tests [1/1]
**** DONE feature-provision                                                  :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/feature-provision ()
  (should (featurep 'org-glance)))
#+END_SRC
* Devtools
#+NAME: devtools-build-require
#+BEGIN_SRC emacs-lisp :results silent
(defun org-glance-devtools/build ()
  (interactive)
  (let ((project-files '("org-glance.el" "org-glance-tests.el")))
    (org-sbe "with-temp-org-buffer")
    (mapc 'delete-file project-files)
    (org-babel-tangle)
    (mapc 'load-file project-files)
    (mapc 'byte-compile-file project-files)

    (let* ((test-$ "^org-glance-test/")
           (test-buffer "*org-glance-tests*")
           (ert-stats (ert-run-tests-interactively test-$ test-buffer))
           (expected (ert-stats-completed-expected ert-stats))
           (unexpected (ert-stats-completed-unexpected ert-stats))
           (skipped (ert-stats-skipped ert-stats))
           (total (ert-stats-total ert-stats))
           (report (list total expected unexpected skipped)))
      (apply 'message (append '("Build finished. Ran %d tests, %d were as expected, %d failed, %d skipped") report)))))

(local-set-key (kbd "C-x y m") 'org-glance-devtools/build)
(org-table-iterate-buffer-tables)
(message "Development tools are now ready to use. Happy hacking!")
#+END_SRC
* Applications
** org-glance-snippets
** org-glance-passwords
** org-glance-bookmarks
** org-glance-fs
* Known issues [0/1]
** TODO Global categories in one buffer override categories in another isolated buffer
* Local Variables
# Local Variables:
# eval: (org-table-iterate-buffer-tables)
# org-use-tag-inheritance: t
# org-src-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
