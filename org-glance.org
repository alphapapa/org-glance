#+TITLE: org-glance
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-glance
#+TAGS: License Documentation
#+TAGS: Feature Test
#+PROPERTY: header-args:emacs-lisp :noweb yes :tangle (cond ((seq-intersection '("Test") (org-get-tags-at)) "org-glance-tests.el") ((seq-intersection '("Feature" "License") (org-get-tags-at)) "yes") (t "no"))
#+PROPERTY: header-args:markdown :tangle (cond ((seq-intersection '("Documentation") (org-get-tags-at)) "README.md") (t "no"))
#+PROPERTY: header-args:org :tangle no

* Hello
** README                                                                      :Documentation:
#+BEGIN_SRC markdown
Org-glance: walk in the woods with pleasure
===============================

Fast, clean and convenient way of traversing your org-mode forest.

Turn org-mode into context-aware bookmark storage, password manager,
flexible build system or whatever you can imagine with ease.
#+END_SRC
** License                                                                     :License:
#+BEGIN_SRC emacs-lisp
;;; org-glance.el --- org-mode traversing. Fast and convenient.

;; Copyright (C) 2018 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 29 September, 2018
;; Version: 0.1

;; Keywords: org-mode tools
;; Homepage: https://github.com/rails-to-cosmos/org-glance

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+END_SRC
* Requirements
** Implementation                                                              :Feature:
#+BEGIN_SRC emacs-lisp
(require 's)
(require 'cl-lib)
(require 'org)
(require 'dash)
#+END_SRC
** Testing                                                                     :Test:
#+BEGIN_SRC emacs-lisp
(require 'ert)
(require 'org-glance)
#+END_SRC
* Features [4/7]
** DONE temp-org-buffer                                                        :Test:
#+NAME: with-temp-org-buffer
#+BEGIN_SRC emacs-lisp
(defmacro with-temp-org-buffer (s &rest forms)
  "Create a temporary org-mode buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (org-mode)
       (goto-char 0)
       (insert ,s)
       (goto-char 0)
       ,@forms)))
#+END_SRC
** TODO org-glance [1/2]                                                       :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance (&rest args)
  "Use optional ARGS to customize your glancing blows:
- SCOPE :: org-file or SCOPE from org-map-entries (org.el)
- PROMPT :: completing read title (default: \"Glance: \")
- SEPARATOR :: completing read entry separator (default: \" → \")
- FILTER :: list or one filter of type lambda/symbol/string to specify entries in completing read.

  Possible default filters:
  - links :: keep entries with link in title
  - encrypted :: keep entries with :crypt: tag

  You can customize default filters by setting org-glance/default-filters variable.

- ACTION :: lambda to call on selected entry
  - if entry has an org-link in title, browse it
  - if entry has HANDLER property, read-eval it
- HANDLER :: property name to read-eval on select (default: \"HANDLER\")
- OUTLINE-PATH-IGNORE :: list of strings to ignore in outline-path

\(fn [:scope SCOPE] [:prompt PROMPT] [:separator SEPARATOR] [:filter FILTER] [:action ACTION] [:handler HANDLER])"
  (let* ((user-scopes (or (plist-get args :scope)          nil))
         (aggregated-scopes (org-glance--aggregate-scopes user-scopes))

         (user-filter (or (plist-get args :filter)       (lambda () t)))
         (filter-predicates (org-glance--filter-predicates user-filter))

         (outline-path-ignore (or (plist-get args :outline-path-ignore) nil))

         (handler   (or (plist-get args :handler)        "HANDLER"))
         (prompt    (or (plist-get args :prompt)         "Glance: "))
         (separator (or (plist-get args :separator)      " → "))
         (action    (or (plist-get args :action)         (lambda nil (org-glance--handle-entry handler)))))

    (cl-flet ((traverse ()
                        (let* ((mark (point-marker))
                               (title (s-join separator (-difference (org-get-outline-path t) outline-path-ignore))))
                          (when (every (lambda (fp) (if fp (funcall fp) nil)) filter-predicates)
                            (cons title mark)))))

      (org-glance/compl-map prompt (org-map-entries #'traverse nil aggregated-scopes) action))))
#+END_SRC
*** TODO Tests
** DONE handle-entry [2/2]                                                     :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance--handle-entry (handler)
  "Try to handle current org-entry:
1. If there is an org-link, browse it.
2. If not, call HANDLER."
  (cond ((org-match-line (format "^.*%s.*$" org-bracket-link-regexp)) (org-glance/follow-org-link-at-point))
        ((org-entry-get nil handler) (let ((action (read (org-entry-get nil handler))))
                                       (cond ((symbolp action) (read (macroexpand (list 'org-sbe (symbol-name action)))))
                                             (t (eval action)))))))
#+END_SRC
*** DONE Tests
**** DONE can-handle-org-links                                               :Test:
***** Predicate
#+BEGIN_SRC emacs-lisp
(defun org-glance-predicate/can-handle-org-links ()
  "Can we handle org-links?"
  (with-temp-org-buffer "* [[elisp:(+%201%202)][elisp]]"
                        (let ((unread-command-events (listify-key-sequence (kbd "elisp RET")))
                              (begin-marker (with-current-buffer (messages-buffer)
                                              (point-max-marker))))
                          (org-glance)
                          (string= (string-trim (with-current-buffer (messages-buffer)
                                                  (buffer-substring begin-marker (point-max))))
                                   "(+ 1 2) => 3"))))
#+END_SRC
***** Explanation
#+BEGIN_SRC emacs-lisp
(defun org-glance-test-explainer/can-handle-org-links ()
  (message "Handling org-links feature doesn't work properly"))

(put 'org-glance-predicate/can-handle-org-links
     'ert-explainer
     'org-glance-test-explainer/can-handle-org-links)
#+END_SRC
***** Test
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-org-links ()
  "Test that we can handle org-links."
  (should (org-glance-predicate/can-handle-org-links)))
#+END_SRC
**** DONE can-handle-default-property                                        :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-default-property ()
  "Test that we can use default handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:HANDLER: (+ 1 9)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance) 10)))))
#+END_SRC
**** DONE can-handle-custom-property                                         :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-custom-property ()
  "Test that we can use custom handler property."
  (with-temp-org-buffer
"
,* Title
:PROPERTIES:
:CUSTOM_HANDLER: (+ 1 11)
:END:
"
(let ((unread-command-events (listify-key-sequence (kbd "tit RET"))))
  (should (= (org-glance :handler "CUSTOM_HANDLER") 12)))))
#+END_SRC
**** DONE can-handle-symbolic-property                                       :Test:
***** Predicate
#+BEGIN_SRC emacs-lisp
(defun org-glance-predicate/can-handle-symbolic-property ()
  "Can we handle symbolic property as org-babel block name?"
  (with-temp-org-buffer
   "
,* Please, handle custom block
:PROPERTIES:
:CUSTOM_HANDLER: custom-block
:END:

,#+NAME: custom-block
,#+BEGIN_SRC emacs-lisp
(+ 15 16)
,#+END_SRC
"
   (let ((unread-command-events (listify-key-sequence (kbd "Plea RET"))))
     (= (org-glance :handler "CUSTOM_HANDLER") 31))))
#+END_SRC
***** Explanation
#+BEGIN_SRC emacs-lisp
(defun org-glance-test-explainer/can-handle-symbolic-property ()
  (message "Failed to handle symbolic property as org-babel block name"))

(put 'org-glance-predicate/can-handle-symbolic-property
     'ert-explainer
     'org-glance-test-explainer/can-handle-symbolic-property)
#+END_SRC
***** Test
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/can-handle-symbolic-property ()
  "Test that we can handle symbolic properties."
  (should (org-glance-predicate/can-handle-symbolic-property)))
#+END_SRC
** TODO compl-map [1/2]                                                        :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance/compl-map (prompt entries action)
  "PROMPT org-completing-read on ENTRIES and call ACTION on selected.
If there is only one entry, call ACTION without completing read.
If there is no entries, raise exception."
  (let* ((entries* (remove 'nil entries))
         (choice (cond ((= (length entries*) 1) (caar entries*))
                       ((= (length entries*) 0) (error "Empty set."))
                       (t (org-completing-read prompt entries*))))
         (marker (cdr (assoc-string choice entries*))))
    (org-goto-marker-or-bmk marker)
    (funcall action)))
#+END_SRC
*** TODO Tests
** TODO follow-org-link-at-point [1/2]                                         :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance/follow-org-link-at-point ()
  "Browse org-link at point."
  (let ((link (buffer-substring-no-properties
               (save-excursion (org-beginning-of-line) (point))
               (save-excursion (org-end-of-line) (point))))
        (org-link-frame-setup (acons 'file 'find-file org-link-frame-setup)))
    (org-open-link-from-string link)))
#+END_SRC
*** TODO Tests
** TODO scoping [1/3]                                                          :Feature:
*** TODO Documentation
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defun org-glance--aggregate-scopes (scopes)
  (let ((scopes (cond ((stringp scopes) (list scopes))
                      (t scopes)))
        aggregated-scope)
    (loop for scope in scopes
          do (cond
              ((and (functionp scope) (bufferp (funcall scope)))
               (add-to-list 'aggregated-scope (expand-file-name (buffer-file-name (funcall scope)))))

              ((stringp scope)
               (add-to-list 'aggregated-scope (expand-file-name scope)))))
    aggregated-scope))
#+END_SRC
*** TODO Tests
** DONE filtering [2/2]                                                        :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(defvar org-glance/default-filters '((links . (lambda () (org-match-line (format "^.*%s.*$" org-bracket-link-regexp))))
                                     (encrypted . (lambda () (seq-intersection (list "crypt") (org-get-tags-at))))))

(defun org-glance--filter-predicates (filter)
  "Factorize FILTER into list of predicates. Acceptable FILTER values:
- list of symbols (possible default filters) and lambdas (custom filters)
- string name of default filter
- symbolic name of default filter
- lambda function with no params called on entry"
  (let* ((predicates (cond ((functionp filter) (list filter))
                           ((symbolp filter) (list (alist-get filter org-glance/default-filters)))
                           ((stringp filter) (list (alist-get (intern filter) org-glance/default-filters)))
                           ((listp filter) (loop for elt in filter
                                                 when (functionp elt) collect elt
                                                 when (symbolp elt)   collect (alist-get elt org-glance/default-filters)
                                                 when (stringp elt)   collect (alist-get (intern elt) org-glance/default-filters)))
                           (t (error "Unable to recognize filter.")))))
    predicates))
#+END_SRC
*** DONE Tests
**** filter-produces-proper-predicates                                       :Test:
***** Predicate
#+BEGIN_SRC emacs-lisp
(defun org-glance-predicate/filter-produces-proper-predicates (input expected)
  "Can we split user filter into atomic predicates?"
  (equal (org-glance--filter-predicates input) expected))
#+END_SRC
***** Explanation
#+BEGIN_SRC emacs-lisp
(defun org-glance-test-explainer/filter-produces-proper-predicates (filter expected)
  (cond ((functionp filter) (message "Unable to resolve lambda filter"))
        ((symbolp filter) (message "Unable to resolve symbolic filter"))
        ((stringp filter) (message "Unable to resolve string filter"))
        ((listp filter) (loop for elt in filter
                              when (functionp elt) do (message "Unable to resolve lambda from filter list")
                              when (symbolp elt)   do (message "Unable to resolve symbol from filter list")
                              when (stringp elt)   do (message "Unable to resolve string from filter list")))
        (t (message "Unrecognized filter must raise an error"))))

(put 'org-glance-predicate/filter-produces-proper-predicates
     'ert-explainer
     'org-glance-test-explainer/filter-produces-proper-predicates)
#+END_SRC
***** Implementation
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-produces-proper-predicates-lambda ()
  (should (org-glance-predicate/filter-produces-proper-predicates
           (lambda () t) '((lambda () t)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-symbol ()
  (should (org-glance-predicate/filter-produces-proper-predicates
           'links (list (alist-get 'links org-glance/default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-string ()
  (should (org-glance-predicate/filter-produces-proper-predicates
           "links" (list (alist-get 'links org-glance/default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-list ()
  (should (org-glance-predicate/filter-produces-proper-predicates
           (list 'links (lambda () t) "links")
           (list (alist-get 'links org-glance/default-filters)
                 (lambda () t)
                 (alist-get 'links org-glance/default-filters)))))
#+END_SRC
**** filter-removes-entries                                                  :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-removes-entries ()
  "Test filtering."
  (with-temp-org-buffer
"
,* First
,* Second
,* Third
,* Security
"
(let ((unread-command-events (listify-key-sequence (kbd "third RET"))))
  (should-error (org-glance :filter (lambda () (org-match-line "^.*Sec")))))))
#+END_SRC
**** filter-doesnt-remove-suitable-entries                                   :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/filter-doesnt-remove-suitable-entries ()
  "Test filtering."
  (with-temp-org-buffer
"
,* First
,* Second
,* Third
"
(let ((unread-command-events (listify-key-sequence (kbd "sec RET"))))
  (should (eq nil (org-glance :filter (lambda () (org-match-line "^.*Second"))))))))
#+END_SRC
** DONE provide [2/2]                                                          :Feature:
*** DONE Implementation
#+BEGIN_SRC emacs-lisp
(provide 'org-glance)
;;; org-glance.el ends here
#+END_SRC
*** DONE Tests [1/1]
**** DONE feature-provision                                                  :Test:
#+BEGIN_SRC emacs-lisp
(ert-deftest org-glance-test/feature-provision ()
  (should (featurep 'org-glance)))
#+END_SRC
* Devtools
** Development Environment
#+NAME: init-denv
#+BEGIN_SRC emacs-lisp
(defun org-glance-devtools/build ()
  (interactive)
  (save-mark-and-excursion
    (org-save-outline-visibility t
      (org-glance
       :filter (lambda () (seq-intersection '("build") (org-get-tags-at)))))))

(local-set-key (kbd "C-x y m") 'org-glance-devtools/build)
#+END_SRC
** Build                                                                       :build:
:PROPERTIES:
:HANDLER:  (and (org-sbe "report") (org-glance-devtools/build-report))
:END:

#+NAME: report
#+BEGIN_SRC emacs-lisp
(defun org-glance-devtools/build-report ()
  (let ((report (read (org-sbe "build"))))
    (caddr report)
    (when (> (caddr report) 0)
      (pop-to-buffer "*org-glance-tests*"))
    (apply 'message (append '("Build finished. Ran %d tests, %d were as expected, %d failed, %d skipped") report))))
#+END_SRC

#+NAME: build
#+BEGIN_SRC emacs-lisp :tangle no :results silent
(let ((test-file "org-glance-tests.el")
      (impl-file "org-glance.el"))
  (delete-file test-file)
  (delete-file impl-file)
  (org-sbe "with-temp-org-buffer")
  (org-babel-tangle)
  (load-file impl-file)
  (byte-compile-file impl-file)
  (load-file test-file)

  (let* ((test-$ "^org-glance-test/")
         (test-buffer "*org-glance-tests*")
         (ert-stats (ert-run-tests-interactively test-$ test-buffer))
         (expected (ert-stats-completed-expected ert-stats))
         (unexpected (ert-stats-completed-unexpected ert-stats))
         (skipped (ert-stats-skipped ert-stats))
         (total (ert-stats-total ert-stats)))
    (list total expected unexpected skipped)))
#+END_SRC
* Applications
** org-glance-build
** org-glance-passwords
** org-glance-bookmarks
** org-glance-fs
* Local Variables
# Local Variables:
# eval: (or (org-sbe "report") (org-glance-devtools/build-report) (org-sbe "init-denv"))
# org-use-tag-inheritance: t
# org-src-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
